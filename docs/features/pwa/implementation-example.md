# PWA Implementation Example for Next.js Better Auth

This document provides a concrete implementation example for adding Progressive Web App (PWA) functionality to this project.

## Step 1: Install Dependencies

First, add the necessary PWA dependencies to the project:

```bash
bun add next-pwa
```

## Step 2: Add PWA Configuration to Next.js Config

Update the `next.config.ts` file with the PWA configuration:

```typescript
// next.config.ts
import { withPWA } from 'next-pwa';

const config = {
  // Existing configuration
};

const nextConfig = withPWA({
  dest: 'public',
  disable: process.env.NODE_ENV === 'development',
  register: true,
  skipWaiting: true,
  // Other Next.js config options...
})(config);

export default nextConfig;
```

## Step 3: Create PWA Assets

### Create a Web App Manifest

Create the file `public/manifest.json`:

```json
{
  "name": "Next.js Better Auth",
  "short_name": "BetterAuth",
  "description": "Next.js authentication application with Drizzle ORM and Turso database",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#000000",
  "icons": [
    {
      "src": "/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}
```

### Create Icons Directory

```bash
mkdir -p public/icons
```

Then add your icon files to this directory.

## Step 4: Update the Root Layout

Modify the root layout file to include necessary PWA meta tags and links.

```tsx
// app/layout.tsx
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import { ThemeProvider } from "@/components/theme-provider";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Next.js Better Auth",
  description: "Next.js authentication application with Drizzle ORM and Turso database",
  manifest: "/manifest.json",
  themeColor: "#000000",
  appleWebApp: {
    capable: true,
    statusBarStyle: "default",
    title: "BetterAuth",
  },
  formatDetection: {
    telephone: false,
  },
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" suppressHydrationWarning>
      <head>
        <link rel="apple-touch-icon" href="/icons/icon-192x192.png" />
      </head>
      <body className={inter.className}>
        <ThemeProvider attribute="class" defaultTheme="system" enableSystem>
          {children}
        </ThemeProvider>
      </body>
    </html>
  );
}
```

## Step 5: Create an Offline Fallback Page

Create a basic offline page at `public/offline.html`:

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Offline - Next.js Better Auth</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      max-width: 500px;
      margin: 0 auto;
      padding: 2rem;
      text-align: center;
      color: #333;
      background-color: #f5f5f5;
    }
    h1 {
      font-size: 1.5rem;
      margin-bottom: 1rem;
    }
    .card {
      background-color: white;
      border-radius: 8px;
      padding: 2rem;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    button {
      background-color: #0070f3;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      margin-top: 1rem;
    }
  </style>
</head>
<body>
  <div class="card">
    <h1>You're currently offline</h1>
    <p>Please check your internet connection and try again.</p>
    <button onclick="window.location.reload()">Try Again</button>
  </div>
</body>
</html>
```

## Step 6: Create a Custom Service Worker (Optional)

For more control over the service worker behavior, create a custom service worker at `public/sw.js`:

```javascript
// This service worker is automatically generated by next-pwa
// However, we're adding custom fetch handling for offline support

const CACHE_NAME = 'better-auth-cache-v1';

// Cache important static assets
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => {
      return cache.addAll([
        '/offline.html',
        '/icons/icon-192x192.png',
        '/icons/icon-512x512.png',
      ]);
    })
  );
});

// Clean up old caches
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames
          .filter((cacheName) => cacheName.startsWith('better-auth-cache-') && cacheName !== CACHE_NAME)
          .map((cacheName) => caches.delete(cacheName))
      );
    })
  );
});

// Network first strategy with offline fallback for HTML pages
self.addEventListener('fetch', (event) => {
  if (event.request.mode === 'navigate') {
    event.respondWith(
      fetch(event.request)
        .catch(() => {
          return caches.match('/offline.html');
        })
    );
  }
});
```

## Step 7: Add PWA Install Button (Client Component)

Create a component to allow users to install the PWA:

```tsx
// components/pwa-install-button.tsx
"use client";

import { useEffect, useState } from "react";
import { Button } from "@/components/ui/button";

export function PWAInstallButton() {
  const [deferredPrompt, setDeferredPrompt] = useState<any>(null);
  const [isInstallable, setIsInstallable] = useState(false);

  useEffect(() => {
    // Listen for the beforeinstallprompt event
    window.addEventListener('beforeinstallprompt', (e) => {
      // Prevent Chrome from automatically showing the prompt
      e.preventDefault();
      // Stash the event so it can be triggered later
      setDeferredPrompt(e);
      // Update UI to notify the user they can add to home screen
      setIsInstallable(true);
    });

    // Listen for app installed event
    window.addEventListener('appinstalled', () => {
      // Log app install
      console.log('PWA was installed');
      // Clear the prompt
      setDeferredPrompt(null);
      // Update UI
      setIsInstallable(false);
    });
  }, []);

  const handleInstallClick = async () => {
    if (!deferredPrompt) return;

    // Show the install prompt
    deferredPrompt.prompt();

    // Wait for the user to respond to the prompt
    const { outcome } = await deferredPrompt.userChoice;

    // Log outcome (accepted or dismissed)
    console.log(`User ${outcome} the installation`);

    // Clear the prompt reference
    setDeferredPrompt(null);
    // Update UI
    setIsInstallable(false);
  };

  if (!isInstallable) return null;

  return (
    <Button onClick={handleInstallClick}>
      Install App
    </Button>
  );
}
```

## Step 8: Add Offline Data Support

Create a utility for offline data storage using IndexedDB:

```tsx
// lib/pwa/offline-storage.ts
import { User } from "@/db/auth";

// Simplified type for user profile
type UserProfile = {
  id: string;
  name?: string | null;
  email: string;
  // Only include non-sensitive fields
};

// IndexedDB database name and version
const DB_NAME = 'better-auth-offline-db';
const DB_VERSION = 1;

// Initialize the database
export async function initDB(): Promise<IDBDatabase> {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);

    // Handle errors
    request.onerror = () => {
      reject(new Error('Failed to open IndexedDB'));
    };

    // Handle successful database open
    request.onsuccess = () => {
      resolve(request.result);
    };

    // Database initialization/upgrade
    request.onupgradeneeded = (event) => {
      const db = request.result;

      // Create object stores
      if (!db.objectStoreNames.contains('userProfile')) {
        db.createObjectStore('userProfile', { keyPath: 'id' });
      }

      // Add more object stores as needed
    };
  });
}

// Save user profile for offline access
export async function saveUserProfile(profile: UserProfile): Promise<void> {
  try {
    const db = await initDB();
    return new Promise((resolve, reject) => {
      const transaction = db.transaction('userProfile', 'readwrite');
      const store = transaction.objectStore('userProfile');

      const request = store.put(profile);

      request.onerror = () => {
        reject(new Error('Failed to save user profile'));
      };

      transaction.oncomplete = () => {
        resolve();
      };
    });
  } catch (error) {
    console.error('Error saving profile to IndexedDB:', error);
    throw error;
  }
}

// Get user profile from IndexedDB
export async function getUserProfile(id: string): Promise<UserProfile | null> {
  try {
    const db = await initDB();
    return new Promise((resolve, reject) => {
      const transaction = db.transaction('userProfile', 'readonly');
      const store = transaction.objectStore('userProfile');

      const request = store.get(id);

      request.onerror = () => {
        reject(new Error('Failed to get user profile'));
      };

      request.onsuccess = () => {
        resolve(request.result || null);
      };
    });
  } catch (error) {
    console.error('Error retrieving profile from IndexedDB:', error);
    return null;
  }
}
```

## Step 9: Integrate with Authentication System

Add a component to sync authentication state with offline storage:

```tsx
// components/auth-sync.tsx
"use client";

import { useEffect } from "react";
import { saveUserProfile } from "@/lib/pwa/offline-storage";

type AuthSyncProps = {
  user: {
    id: string;
    name?: string | null;
    email: string;
  } | null;
};

export function AuthSync({ user }: AuthSyncProps) {
  useEffect(() => {
    // Only save non-sensitive user data when logged in
    if (user) {
      saveUserProfile({
        id: user.id,
        name: user.name,
        email: user.email,
      }).catch(console.error);
    }
  }, [user]);

  // This is a non-visual component
  return null;
}
```

Use this component in your layout:

```tsx
// app/[locale]/dashboard/layout.tsx
import { auth } from "@/lib/auth";
import { AuthSync } from "@/components/auth-sync";

export default async function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const session = await auth();
  const user = session?.user || null;

  return (
    <>
      {/* Only sync when user is logged in */}
      {user && <AuthSync user={user} />}
      <main>{children}</main>
    </>
  );
}
```

## Testing Your PWA Implementation

1. Build the application for production:
   ```bash
   bun run build
   ```

2. Start the production server:
   ```bash
   bun run start
   ```

3. Open Chrome DevTools and navigate to the Application tab:
   - Check the "Manifest" section to verify your web app manifest
   - Look at the "Service Workers" section to confirm registration
   - Use the "Cache Storage" section to view cached assets
   - Check "IndexedDB" to see your offline data store

4. Test offline functionality by:
   - Enabling offline mode in DevTools
   - Disconnecting your network
   - Reloading the application to see offline behavior

## Production Considerations

1. **Security**: Review what data is stored offline to ensure sensitive information is protected
2. **Performance**: Monitor the size of your service worker and cached assets
3. **Updates**: Implement a strategy for notifying users of new versions
4. **Analytics**: Track PWA installations and offline usage patterns
